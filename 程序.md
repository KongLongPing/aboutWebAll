#### MYSQL数据库相关

```
SQL_MODE

select  @@sql_mode

ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE,  ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER, and NO_ENGINE_SUBSTITUTION 

set GLOBAL sql_mode='ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE,  
ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER, and NO_ENGINE_SUBSTITUTION'


mysql> source import_source.sql;
mysql> show status;  #查看数据库状态
mysql> show variables like '%connect%' #查询数据库配置变量
mysql> set global slow_query_log=1  #临时开启慢日志查询
mysql> set global long_query_time=2  #设置长查询时间为2s
mysql> set innodb_file_per_table=1  #开启innodb每个表有一个独立空间.
mysql> show create table table_name  #查看表创建信息
mysql> explain partitions select * from table_name where id=111;  #查看查询涉及的分区信息
mysql> /* 注释 */  /*! 执行SQL */ /*!50001  SQL版本大于5的版本执行 */

mysql> optimize table table_name  # 优化表空间.. 主要针对的是MyISAM类型的表
mysql> alter table table_name ENGINE='InnoDB';  # 该方法会对旧表以复制的方式新建一个新表，然后删除旧表.过程是安全的.相当于 optimize 重新整理数据表.
mysql> show processlist; # 显示运行的线程及状态  ****主要是长连接 或 连接池的状态..
mysql> set profiling=1; #  开启 profile SQL剖析
mysql> show profiles; # 查看所有查询信息
mysql> show profile ALL for query 1;#  查看所有信息为1profile执行 ALL
mysql> show profile cpu,block io for query 1;
+----------------------+----------+----------+------------+--------------+---------------+
| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |
+----------------------+----------+----------+------------+--------------+---------------+
| starting             | 0.000068 | 0.000000 |   0.000000 |         NULL |          NULL |
| checking permissions | 0.000006 | 0.000000 |   0.000000 |         NULL |          NULL |
| Opening tables       | 0.000027 | 0.000000 |   0.000000 |         NULL |          NULL |
| init                 | 0.000049 | 0.000000 |   0.000000 |         NULL |          NULL |
| System lock          | 0.000018 | 0.000000 |   0.000000 |         NULL |          NULL |
| optimizing           | 0.000005 | 0.000000 |   0.000000 |         NULL |          NULL |
| statistics           | 0.000015 | 0.000000 |   0.000000 |         NULL |          NULL |
| preparing            | 0.000008 | 0.000000 |   0.000000 |         NULL |          NULL |
| executing            | 0.000001 | 0.000000 |   0.000000 |         NULL |          NULL |
| Sending data         | 0.000100 | 0.000000 |   0.000000 |         NULL |          NULL |
| end                  | 0.000003 | 0.000000 |   0.000000 |         NULL |          NULL |
| query end            | 0.000006 | 0.000000 |   0.000000 |         NULL |          NULL |
| closing tables       | 0.000006 | 0.000000 |   0.000000 |         NULL |          NULL |
| freeing items        | 0.000045 | 0.000000 |   0.000000 |         NULL |          NULL |
| cleaning up          | 0.000008 | 0.000000 |   0.000000 |         NULL |          NULL |
+----------------------+----------+----------+------------+--------------+---------------+

mysqldump -uroot -p abc > abc.sql #导出
mysqldump -uroot -p -d abc > abc.sql #export structure
mysql> source /home/abc/abc.sql; #导入 mysql -uabc -p abc < abc.sql

```

##### SQL 分区

```
#创建表并分区.  采用list分区.  数据存储在 vc_kline_stat_temporary#p#4hour.ibd 数据文件里面
CREATE TABLE `vc_kline_stat_temporary` (
      `interval_type` int(11) NOT NULL COMMENT '时段类型：101(1分钟)、103(3分钟)、105(5分钟)、115(15分钟)、130(30分钟)、201(1小时)、204(4小时)、301(1天)、305(5天)、401(1周)、501(1月)',
      `trade_vcoin_code` varchar(50) NOT NULL COMMENT '买卖币代码',
      `start_time` varchar(25) NOT NULL COMMENT '起始时间',
      `open` decimal(28,10) NOT NULL DEFAULT '0.0000000000' COMMENT '开盘价',
      `count` int(11) NOT NULL DEFAULT '0' COMMENT '成交笔数',
      `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
      PRIMARY KEY (`interval_type`,`trade_vcoin_code`,`basic_vcoin_code`,`start_time`),
      KEY `idx_start_time` (`start_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='币币K线图统计信息表'
/*!50100 PARTITION BY LIST (interval_type)
    (PARTITION 1min VALUES IN (101) ENGINE = InnoDB,
     PARTITION 3min VALUES IN (103) ENGINE = InnoDB,
     PARTITION 5min VALUES IN (105) ENGINE = InnoDB,
     PARTITION 15min VALUES IN (115) ENGINE = InnoDB,
     PARTITION 30min VALUES IN (130) ENGINE = InnoDB,
     PARTITION 1hour VALUES IN (201) ENGINE = InnoDB,
     PARTITION 4hour VALUES IN (204) ENGINE = InnoDB,
     PARTITION 1day VALUES IN (301) ENGINE = InnoDB,
     PARTITION 5day VALUES IN (305) ENGINE = InnoDB,
     PARTITION 1week VALUES IN (401) ENGINE = InnoDB,
     PARTITION 1month VALUES IN (501) ENGINE = InnoDB) */
##if 用处..  
SELECT
	sum(

		IF (
			ual.direct = "in" ,
     		- ual.count * 10,
			ual.count * 10
		)
	)
FROM
	vc_user_account ua
LEFT JOIN vc_user_account_log ual ON ual.user_account_id = ua.id
WHERE
	ua.vcoin_code = "GTC"
AND ual.user_id = 53
AND ual.created_at BETWEEN "2019-04-01 00:00:01"
AND "2019-04-07 23:59:59"
```

##### 主从集群  replication  和 Cluster

```


```

##### 数据库索引

```
Hash索引::::
Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
Hash 索引无法被用来避免数据的排序操作。
Hash 索引在任何时候都不能避免表扫描。
Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
（hash 在mylsam数据表存储是范围存放，只按照节点查找，一旦多个hash值索引节点，那么就要在数据表多个位置寻找，比InnoDB中索引和数据在同一节点寻找复杂得多，所以不推荐hash）

B-Tree索引: binary tree 二叉树索引::::

```



#### PostgreSql

```



```

#### 程序相关

#### 工具相关

##### Redis

###### 杂项

```
redis作为服务启动
redis-server --service-install redis-windows.conf
redis-server --service-start
设置访问密码:  redis.conf  ==>requirepass  test12345
                或者	redis>config set requirepass test12345
                查询密码 redis>config get requirepass
远程登录: ./redis-cli -h 127.0.0.1 -p 4379 -a test12345password
或者:     ./redis-cli -h 127.0.0.1 -p 4370
		redis>auth test12345password
允许外部访问:
bind 127.0.0.1 >注释掉
protected-mode yes >改为no

启动websocket---ws

常用指令:
keys  pattern[*]  列出所有key
get keyname  获取指定key的值
set key value [EX seconds] [PX milliseconds] [NX|XX]
INCR key  值自增1   扩展+: =>INCRBY key step =>INCRBYFLOAT key step
DECR key  值自减1   扩展+: =>DECRBY key step =>
APPEND key value;  追加字符串到key 值的末尾;



```

###### redis info

```
# Server
redis_version:4.0.11
tcp_port:6379
uptime_in_seconds:10029228
uptime_in_days:116
hz:10
lru_clock:11978282

# Clients
connected_clients:0
client_longest_output_list:0
client_biggest_input_buf:14
blocked_clients:0

# Memory
used_memory:324013616
used_memory_human:309.00M
used_memory_rss:319913984
used_memory_rss_human:305.09M
used_memory_peak:326859144
used_memory_peak_human:311.72M
used_memory_overhead:322136972
used_memory_overhead_human:307.21M
used_memory_startup:51828560
used_memory_startup_human:49.43M
used_memory_dataset:1876644
used_memory_dataset_human:1.79M
used_memory_lua:303104
used_memory_lua_human:296.00K
maxmemory:17179869184
maxmemory_human:16.00G
maxmemory_policy:volatile-lru
mem_fragmentation_ratio:0.98
mem_allocator:jemalloc-4.0.3
active_defrag_running:0
lazyfree_pending_objects:0

# Stats
total_connections_received:13190119
total_commands_processed:1259000743
instantaneous_ops_per_sec:115
total_net_input_bytes:145997882739
total_net_output_bytes:490183197430
instantaneous_input_kbps:4
instantaneous_output_kbps:37
rejected_connections:0
sync_full:8
sync_partial_ok:0
sync_partial_err:0
expired_keys:3598875
evicted_keys:0
keyspace_hits:435798010
keyspace_misses:171420900
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:2450
migrate_cached_sockets:0

# Replication
connected_slaves:1
slave0:ip=11.195.214.210,port=3038,state=online,offset=8308841911,lag=0,opid=40407225
master_replid:ec967f3140ad5bca8c42c07818801338f3291c8d
master_replid2:1e320851338c648e59945ce910509ca642b3dfd6
master_repl_offset:8308841911
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:33554432
repl_backlog_first_byte_offset:8275287480
repl_backlog_histlen:33554432

# CPU
used_cpu_sys:262198.34
used_cpu_user:95673.20
used_cpu_sys_children:1.03
used_cpu_user_children:0.21

# Cluster
cluster_enabled:0
databases:256
nodecount:8

# Keyspace
db0:keys=324,expires=104,avg_ttl=14427313
```

###### redis 主从 replication

```


port 9997
logfile /usr/local/redis/logs/redis.log.9997
#指定master ip port
slaveof 172.17.84.39 9999
#认证master时需要的密码。必须和master配置的requirepass 保持一致
masterauth redispass
protected-mode no
shell> ./redis-server ../conf/redis.conf
改名趣事:  master - slave 涉及  
将 master-slave 架构的描述改为 master-replica  
为 SLAVEOF 提供别名 REPLICAOF，所以仍然可以使用 SLAVEOF，但多了一个选项
https://www.oschina.net/news/99797/redis-master-slave-terminology
###########################################################################################################################################################
Redis的主从同步机制可以确保redis的master和slave之间的数据同步。按照同步内容的多少可以分为全同步和部分同步；按照同步的时机可以分为slave刚启动时的初始化同步和正常运行过程中的数据修改同步；本文将对这两种机制的流程进行分析。
全备份过程中，在slave启动时，会向其master发送一条SYNC消息，master收到slave的这条消息之后，将可能启动后台进程进行备份，备份完成之后就将备份的数据发送给slave，初始时的全同步机制是这样的：
（1）slave启动后向master发送同步指令SYNC，master接收到SYNC指令之后将调用该命令的处理函数syncCommand（）进行同步处理；
（2）在函数syncCommand中，将调用函数rdbSaveBackground启动一个备份进程用于数据同步，如果已经有一个备份进程在运行了，就不会再重新启动了。
（3）备份进程将执行函数rdbSave（）完成将redis的全部数据保存为rdb文件。
（4）在redis的时间事件函数serverCron（redis的时间处理函数是指它会定时被redis进行操作的函数）中，将对备份后的数据进行处理，在serverCron函数中将会检查备份进程是否已经执行完毕，如果备份进程已经完成备份，则调用函数backgroundSaveDoneHandler完成后续处理。
（5）在函数backgroundSaveDoneHandler中，首先更新master的各种状态，例如，备份成功还是失败，备份的时间等等。然后调用函数updateSlavesWaitingBgsave，将备份的rdb数据发送给等待的slave。
（6）在函数updateSlavesWaitingBgsave中，将遍历所有的等待此次备份的slave，将备份的rdb文件发送给每一个slave。另外，这里并不是立即就把数据发送过去，而是将为每个等待的slave注册写事件，并注册写事件的响应函数sendBulkToSlave，即当slave对应的socket能够发送数据时就调用函数sendBulkToSlave（），实际发送rdb文件的操作都在函数sendBulkToSlave中完成。
（7）sendBulkToSlave函数将把备份的rdb文件发送给slave。

```



##### git

```
git安装用户
ssh-keygen -t rsa -C "konglingping@126.com"

git config --global user.name
git config --global user.email
git clone git/http协议

git branch
git checkout Dev
git checkout -b new-branch-name
git log 查看提交记录

git rm -r -n --cached  user/  放弃追踪user/
git rm -r --cached user/  放弃追踪user/
vi .gitignore 添加不被追踪文件或文件夹

git init  初始化
git branch -d branch-name 删除分支
git clone -b branch-name  git_url 从远程分支clone => git clone -b Dev git://192.168.1.1/master.git
git add  file/path  添加到暂存区
git commit -m message info 提交文件到工作目录
git push origin Dev  提交当前到远程..
git pull ##相当于 git fetch  && git merge

冲突:
git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp
git diff temp//比较master分支和temp分支的不同
git merge temp//合并temp分支到master分支
git branch -d temp//删除temp

git reset HEAD  文件.txt  撤销文件.txt commit状态
git clean -f 清除untracked 文件.
##############error: Your local changes to the following files would be overwritten by merge:
git reset --hard 回滚到上一个版本..
##########
git stash
git pull origin Dev
git stash pop
#####强制覆盖本地
git fetch --all  #抓取远程分支
git reset --hard origin/Dev  #强制覆盖本地originDev
git pull  #抓取分支并合并.


```



##### Swoole

```
Timer 定时器;
	swoole_timer_tick(int $msec,$callback_function); ###多次执行( 相当于setInterval() )
	swoole_timer_after(int $after_time_msec_once,$callback_function); ###一次性(相当于setTimeout)
	swoole_timer_clear(int $timer_id); ###删除定时器

```



##### PHP相关

```
$tStart=microtime(true);   返回当前时间戳微秒

memory_get_usage();  返回当前分配给你的 PHP 脚本的内存量，单位是字节

getrusage(1)  获取当前资源使用状况
$dat = getrusage();
echo $dat["ru_nswap"];         // number of swaps
echo $dat["ru_majflt"];        // number of page faults
echo $dat["ru_utime.tv_sec"];  // user time used (seconds)
echo $dat["ru_utime.tv_usec"]; // user time used (microseconds)

优化：
	尽量避免在循环里面查询数据库 和 执行文件操作..
	加载速度优化:  
		发起请求的 花费的时间...
		
		waiting的等待时间:(后台相关)
            数据库查询字段优化(列表尽量不要查询text blob 能长字段);
            循环里面尽量不要去查询数据库和读取文件内容;
            循环里面的配置信息能用缓存的尽量用缓存;
		content download:(网络发送数据的时间)
		performance:(Raster, GPU) 渲染时间
		
```

###### HTTP 接口相关

```

```

##### laravel

###### 路由分发二开架构

```
//扩展命名空间 和对应的路由信息
$app->group(['namespace'=>'App\Http\Controllers\Api'],function($app) use ($routefiles){
    include_once $routefiles;
});
$app->any('/',function(){});
$app->group(['prefix'=>'api','middleware'=>'auth'],function($app){
    $app->any('/user/{id}',"UserController@get");
});

User::where()->where(function($que) use ($id){
    $que->where()->orWhere();
})->where()->orWhere();

```

###### 容器相关

```
Application extends Containner{}
$app=new Application();
#####容器绑定实例
$app->instance($abstract, $instance);	####### 可以看到在 instance 方法中，首先移除已经存在的相同的别名，然后将对象存入 $this->instance 数组中。然后完成了绑定。

$app->bind($abstract, $concrete = null, $shared = false); #######绑定一个实例到容器【封装了一个闭包到数组】
$this->app->bind('namess', function ($app) {
	return new HelpSpot\API($app->make('HttpClient'));
});
在 bind 方法中 首先移除旧的实例，绑定的对象实例一般是放在闭包中，如果第二个参数不是闭包，是类名，会通过 getClosure 函数将类名封装进闭包中，然后在闭包中通过容器的 make 或 build 函数解析该类。绑定会将相应的闭包以及是否 share 放进 $this->bindings 数组中。在解析的时候调用。

$app->singleton($abstract, $concrete = null);  	#######【ABC\A\B::class  php5.5之后 解析成 'ABC\A\B' 字符串;】
	==>  $this->bind($abstract,$concrete,true); #######绑定到容器的对象只会被解析一次，之后的调用都返回相同的实例【单例模式】

#####容器解析实例
$app->make('user'); 		#######从容器中解析解析出具体服务实例
$app->build('user');		#######从容器中解析给定的对象类型。

####注册服务ServiceProvider #######服务提供者.
$app->register();			###### 注册服务提供者.
class UserProvider extends ServiceProvider{
	/*
	*在 register 方法中，你只需要将类绑定到 服务容器 中。而不需要尝试在 register 方法中注册任何事件监听器、
	*路由或者任何其他功能。否则，你可能会意外使用到尚未加载的服务提供器提供的服务。
	*/
    public function register(){
        $this->app->singleton('auth',function(){
            return new \App\Helper();
        });
    }
    /*当需要处理具有依赖关系的业务逻辑时，应该将这些逻辑处理放置到 boot 方法内。在 boot 方法中我们可以去完成：注册事件监听器、
    *引入路由文件、注册过滤器等任何你可以想象得到的业务处理。
    */
    public function boot(){
        $this->app['auth']->viaRequest('api', function ($request) {
            $token = $request->input('_token');
            if (empty($token)) {
                $token = isset($_SERVER['HTTP_X_USER_TOKEN']) ? $_SERVER['HTTP_X_USER_TOKEN'] : null; // header name: token
            }
            if (!empty($token)) {
                // return User::where('api_token', $request->input('api_token'))->first();
                if (starts_with($token, 'A_')) {
                    return Helper::getAdminAuthToken($token);
                } elseif (starts_with($token, 'AG_')) {
                    return Helper::getAgentAuthToken($token);
                } elseif (starts_with($token, 'M_')) {
                    return Helper::getUserDemoAuthToken($token);
                } else {
                    return Helper::getUserAuthToken($token);
                }
            }
        });
    }
}
########门面
class Cache extends Facade
{
    /**
     * 获取组件注册名称
     *Cache 门面继承 Facade 基类并定义了 getFacadeAccessor 方法，该方法的工作就是返回服务容器绑定类的别名，
     *当用户引用 Cache 类的任何静态方法时，Laravel 从服务容器中解析 cache 绑定，然后在解析出的对象上调用所有请求方法（本例中是 get）。
     * @return string
     */
    protected static function getFacadeAccessor() { 
        return 'cache'; 
    }
}
use Cache;
class AbControlelr{
    public function __construct(){
        Cache::get('name');
    }
}


```



###### 数据操作

```
数据迁移:::
php artisan make:migration create_users_table  创建迁移
//可为数据库添加新的数据表、字段或索引

public function up(){
    Schema::create("table_name",function(Blueprint $table){
        $table->increments('id')->comment('ss');
        $table->string('username')->comment("用户名");
    	$table->tinyInt('age')->default(0)->nullable();
    	$table->primary('id');
    });
    //修改
    Schema::table('table_name',function(Blueprint $table){
        $table->decimal('money',10,2)->after('username')->change();//修改
        $table->decimal('poerson',10,2);//添加字段
        $table->renameColumn("fromname","toname");//修改字段名称
        $table->dropColumn("other_name"); //删除出字段.
        $table->unique('username');//创建唯一索引
        $table->index(['username','password']);//创建普通索引
    });
}
//回滚迁移
public function down(){
    Schema::drop("table_name");
}


php artisan migrate  执行迁移
php artisan migrate --force  强制迁移
php artisan migrate --path=database/migrations/singledir  迁移某一个目录的文件..

数据填充:::

composer dump-autoload  #重新生成Composer自动加载器
php artisan make:seeder GradeTableSeeder 创建 seeder 数据创建

public function run(){
    DB:table("user")->insert([
        ['username'=>"zhsan",'password'=>md5('password')]
    ]);
    //模型填充  生成条件模型填充数据
    factory(\App\User::class,5)->create();
}
database\factories\ModelFactory.php
$factory->define(App\User::class,function(Faker\Generator $faker){
   return [
       'name'=>$faker->name,
       'age'=>$faker->tinyInt,
       'email'=>$faker->unique()->safeEmail
   ];
});

php artisan db:seed --class=GradeTableSeeder  执行seeder数据
```
###### 任务分发

```
dispatch(new Job());
分发的工作对象必须继承自 Job 并实现 handle()；方法
class TestJob extend Job{
    public function __construct(){}
    public function handle(){}
}
//分发任务
Help::dispatch{
	return app(Dispatcher::class)->dispatch($job);
}
E:\work\site\vendor\illuminate\bus\BusServiceProvider.php
注册服务:
$this->app->singleton('Illuminate\Bus\Dispatcher', function ($app) {
		  //创建一个dispatcher分发对象. 传入当前对象.和依赖的闭包函数
            return new Dispatcher($app, function ($connection = null) use ($app) {
                return $app['Illuminate\Contracts\Queue\Factory']->connection($connection);
            });
});
真正执行的对象
E:\work\site\vendor\illuminate\bus\Dispatcher.php
public function __construct(Containner $app,Closure $func){
    $this->containner=$app;
    $this->queueResolver=$func;
}
这里command就是$job
public function dispatch($command){
	//判断是否队列对象 如果是就分发队列
    if ($this->queueResolver && $this->commandShouldBeQueued($command)) {
    	return $this->dispatchToQueue($command);
    } else {
    	//立即执行
    	return $this->dispatchNow($command);
    }
}

```

##### PHPdocumentor

```
php 下载 http://phpdoc.org/phpDocumentor.phar
php phpDocumentor.phar -d "代码路径" -t "生成的文档路径"
php phpDocumentor.phar template:list 查看可用的列表信息

```
##### PHPunit

```


```

##### Vue相关

```
在api.js里面 使用Vue对象.
import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
var exvue=new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>'
})
export default  exvue;  //导出对象
在api.js里面
	import contextVue from '../main.js'
	console.log(contextVue);
	
	
	

package.json 有很多项目的依赖包，表示在开发项目的时候要有对第三方模块的依赖，依赖都放在这
package-lock.json package的锁文件，帮我们确定安装的第三方模块的具体版本，保持团队编程的统一 
LICENSE 开源协议的说明
index.html 项目默认首页模板文件 
postcssrc.js 是对postcss的一个配置项 
eslintrc.js 规定代码规范，不规范的进行错误提示 
eslintignore 这里写的“build，config，dist和根目录下的JS”，eslintrc就不会对这几个家伙进行代码检测 
editorconfig 对编辑器进行配置，比如：按空格缩两格，charset=utf-8
.babelrc 语法解析器，对.vue文件进行转换，转换成浏览器可以识别的代码 
static文件夹 放静态资源，比如图片，json文件 node-modules 第三方依赖的包 
src 整个项目源代码 
src/main.js 整个项目入口文件
src/app.vue 项目最原始的根组件 
router 路由 
components 项目需要的组件 
assets 放静态资源
config/index.js 基础的配置 
config/dev.env.js 开发环境的配置 
config/prod.env.js 线上环境的配置 
build weback的内容
```
###### 配置文件说明

![vue项目文件结构图](C:\Users\Administrator\Desktop\typora\vueconfig.png)

##### Node.js

```
node  TaskMain.js "param1" "param2"  运行参数
npm install cnpm -g --registry=https://registry.npm.taobao.org
```

###### 定时任务组件

```

```

###### websocket

```
socket.io
node "E:\trademanager\ws\src\app\VcoinMain.js" "E:\trademanager\ws\config_deploy.js" > "E:\trademanager\ws\stdout\ws_%d%.log"
```

##### webpack

```

```

##### Apache Nginx相关配置

```

```

##### 区块链理论相关

```

```



#### 操作系统相关

##### windows

###### 杂项

```
set path=%path%;c:Go;

安装go环境:

交易所websocket服务:
node "E:\trademanager\ws\src\app\VcoinMain.js" "E:\trademanager\ws\config_deploy.js" > "E:\trademanager\ws\stdout\ws_%d%.log"
交易所团队市值更新服务:
node "E:\trademanager\task\src\app\TaskMain.js" "E:\trademanager\task\config_deploy.js" "teamtest" > "E:\trademanager\task\stdout/run_teamtest.log"

#####################################################
set 查看环境变量
set Path 查看Path环境变量
set Path=%Path%;D:\hello;  添加环境变量;


```



##### Linux

###### Centos7

```
SSHD远程登录

groups 查看组（ /etc/group）
useradd 添加用户
passwd 设置密码

安装ipconfig:
yum search ifconfig
yum install ....

在Centos 7 中 systemctl (system control) 是设置系统服务的命令，即 service , 它融合之前service和chkconfig的功能于一体;
shell#> systemctl  # 输出所有正在运行的服务 可以列出正在运行的服务状态，如图：(基本不为人所读， 内容复杂、全面
shell#> systemctl list-units  #输出所有的运行服务
shell#> systemctl list-units --type=service #查看服务列表状态
shell#> systemctl list-unit-files #列出所有已经安装的  服务  及  状态      （可为人所读,  内容简略、清晰）：
shell#> systemd-cgls   ##以树形列出正在运行的进程，它可以递归显示控制组内容 
shell#> systemctl start postfix.service  # 开启一个服务
shell#> systemctl stop postfix.service   # 关闭一个服务
shell#> systemctl restart postfix.service  # 重启一个服务
shell#> systemctl status postfix.service  # 查看服务状态
shell#> systemctl enable postfix.service  # 设置开机启动
shell#> systemctl disable postfix.service  # 设置开机禁用
shell#> systemctl list-unit-files | grep enabled  # 查看已启动的服务列表

安装iptables(默认是firewalld): ---> 防火墙相关 <---
> systemctl list-unit-files |grep firewalld 
> systemctl stop firewalld.service
> systemctl disabled firewalld.service
> yum search iptables
> yum install -y iptables
> yum update iptables
> yum install -y iptables-services
> systemctl enable iptables.service
> systemctl start iptables.service

>firewall-cmd --state
> firewall-cmd --permanent --add-port=80/tcp # --add-port 参数，该参数直接引用端口号及其将使用的网络协议（在本例中为TCP）。 
										 # --permanent 参数，它告诉 firewalld 在每次服务器启动时加载此规则
> firewall-cmd --permanent --add-port=443/tcp #
> firewall-cmd --reload  #重新加载使当前规则生效
> firewall-cmd --list-serivces #查看当前防火墙上的设置
> firewall-cmd --zone=public --list-ports 查看所有打开的端口
> firewall-cmd --zone= public --query-port=80/tcp ##查看
> firewall-cmd --zone= public --remove-port=80/tcp --permanent ##删除
### Removed symlink /etc/systemd/system/basic.target.wants/iptables.service
### Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
### Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.

iptale规则修改:(INPUT行为总结：dport指本地，sport指外部 #######  OUTPUT行为总结：dport指外部，sport指本地)
>iptables -A OUTPUT -p tcp -d bigmart.com -j ACCEPT  允许访问bigmart.com -A 输出 -p tcp tcp协议 -d bigmart.com服务 -j ACCEPT 接受请求
>iptables -A INPUT -p tcp --dport 80 -j DROP  不允许输入80端口 
>iptables -A INPUT -p tcp -s 192.168.1.100 --dport 8080 -j DROP

####批量kill进程
>  kill -s 9 `pgrep node`
>  ps -ef|grep VcoinMain.js|grep -v grep|awk '{print $2}'| xargs kill -9
####查看磁盘情况
> df -h  查看整个磁盘还剩多少空间，可以使用命令df -h
> du --max-depth=1 -h  #查看当前路径下目录大小..
####查看登录用户状态
> w  ##w命令查看所有在线用户 TTY表示终端设备  pts表示虚拟终端设备
> last -5 ##查看登录记录的最后5个登录信息，查看登录状态
> echo “你被管理员踢出了” > /dev/pts/0 && fuser -k /dev/pts/0 ## 发送消息给他，然后再踢他
> fuser -k /dev/pts/0  #踢出用户命令
	---命令解释： fuser：干他（fuck user） -k : 杀了（kill）/dev/pts/0 ：虚拟终端号0
	--- pkill -kill -t TTY值 	踢掉已登录用户

grubby --update-kernel=ALL --args="video=hyperv_fb:1600x900"  修改centOsLinux 的分辨率
######中文语言乱码
> yum install -y "fonts"
> locale -a|grep zh_CN
> vi /etc/locale.conf

```

###### YUM

```
yum install -y 安装
yum remove 卸载
yum grouplist 查看可用软件套件
yum list 查看单个软件
yum groupinstall  "GNOME Desktop" 安装套件
yum grouplist | more 查看所有软件套装
yum grouplist | grep Development 查看所有开发工具软件套装 
yum groupinfo Development tools  查看 开发工具软件套装 详细
yum -y groupinstall Development tools 安装开发工具软件套装
```



###### 常用命令

```
ls -l ==> ll
ll -aux => 显示所有用户的文件
ll -ah  显示大小
ll -ah | grep 管道筛选
ll -Sh 根据文件大小排序 ll -rt  根据时间排序

nohup 命令后台服务运行.（no hang up 不挂断的意思）
nohup command > nohup.out    关闭标准输入，终端不再能够接收任何输入(标准输入),重定向标准输出和标准错误到当前目录下的nohup.out文件
nohup command > nohup.out &  将sh command 任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。
kill pid  或 killall pid  关闭进程

防火墙:
	/etc/sysconfig/iptables  配置文件
修改hosts
	vi /etc/hosts



```

###### 网络 端口扫描

```
netstat   -lntp    --inet 
                        netstat参数解释：
                        -l  (listen) 仅列出 Listen (监听) 的服务
                        -t  (tcp) 仅显示tcp相关内容
                        -n (numeric) 直接显示ip地址以及端口，不解析为服务名或者主机名
                        -p (pid) 显示出socket所属的进程PID 以及进程名字
                        --inet 显示ipv4相关协议的监听
                   
nmap （network mapper）Linux下面的网络扫描和嗅探工具包
nmap 47.74.238.1 -p1-3306  扫描端口1-3306
nmap 47.74.238.1 -p1-299,778,779  扫描端口多个端口
nmap  -sU  10.0.1.161  -Pn  【-sU：表示udp scan ， udp端口扫描 -Pn：不对目标进行ping探测（不判断主机是否在线）（直接扫描端口）】
nmap 10.0.1.161  10.0.1.162 或 nmap 10.0.1.161,162 扫描多个ip
nmap 10.0.1.161-162 连续扫描多个ip  10.0.1.161到162
nmap 10.0.3.0/24  扫描一个子网段所有ip
namp 10.0.3.0/24 --exclude 10.0.3.10 排除某个ip【
										    --exclude 10.0.3.10-20  排除连续的，可以使用横线连接起来
										    --exclude 10.0.3.5,10.0.3.8 排除分散的，使用逗号隔开
                                                --excludefile exips.txt  扫描多个地址时排除文件里的IP地址
                                            	】
```



###### 内容输出相关

```
##############内容输出####################################
cat -n 文件路径 | tail -n +5 | head -n 6   // 显示 5 ～ 10 行的内容， 包括5 和10
tail -n +iLinNum    ###从ILinNum开始显示到结束的内容
tail -n iLinNum     ###显示最后 iLinNum 行的内容
head -n iLinNum     ##显示开头 iLinNum 行的内容
head -n +iLinNum    ##同 head -n iLinNum
tail log.txt -n 50  ##显示最后50条内容
head log.txt -n 50  ##显示前50行内容 ==> head log.txt -n +50
```



###### 环境变量

```
export 查看环境变量
echo $PATH 查看path环境变量
export PATH=/home/hello/bin:$PATH  添加临时环境变量
vim /etc/profile 在最后添加 export PATH="/home/hello/bin:$PATH" 保存退出运行 source /etc/profile
source  命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录  source /etc/profile

```

###### 安装node

```
wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz
tar zxvf node-v0.10.24.tar.gz
cd node-v0.10.24
./configure --prefix=/usr/local/node/0.10.24
make && make install
vi /etc/profile  #末尾添加 环境变量
    export NODE_HOME=/usr/local/node/0.10.24
    export PATH=$NODE_HOME/bin:$PATH
source /etc/profile  #使变量生效
```

###### CronTab计划任务

```
/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名
/etc/crontab 这个文件负责调度各种管理和维护任务。
/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。
我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。

crontab [-u username] 没有U参数表示当前用户下的计划任务
crontab -u root -l  列出root用户的所有计划任务
crontab -e 编辑当前用户的的计划任务
* * * * * myCommand  每分钟执行myCommand
crontab -r 删除工作任务

我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。
最小是分钟级别.
crontab的命令构成为 时间+动作，其时间有分、时、日、月、周五种，操作符有
    * 取值范围内的所有数字
    / 每过多少个数字  * */1 * * * /etc/init.d/smb restart #每一小时重启smb
    - 从X到Z 
    ，散列数字  3,15 * * * * myCommand
   	   * 23-7/1 * * * /etc/init.d/smb restart 晚上11点到早上7点之间，每隔一小时重启smb
 查看执行日志:
 日志默认在 /var/log/cron
 tail /var/log/cron -n 500 查看最后的500条记录

    
```



##### MYSQL

```
create user 'username'@'host' identified by 'passsword'
grant  privileges on databasename.tablename to 'username'@'host'
```



##### Hyper-V

```
hyper-v 管理器:
	hyper-v设置
	虚拟交换机管理器
新建虚拟机.
	关闭启用安全启动;
```





#### 区块链杂项

##### 比特币

```
比特币钱包: bitcoin core:
默认同步区块地址:
C:\Users\Administrator\AppData\Roaming\Bitcoin
修改bitcoin.conf==> datadir=D:\blocksvs

```

##### 虫洞社区

```
https://www.chongdongshequ.com/tags/23.html

```

##### 相关理论

```
https://www.chongdongshequ.com/tags/23.html

```



#### 测试层

```
 //记录上月持仓数值  交换值.
 $update_sql1="UPDATE vc_user SET user_last_month_market_value = user_this_month_market_value,team_last_month_market_value=team_this_month_market_value";
 DB::update(DB::raw($update_sql1));

//第一天本月团队,个人市值
$update_sql2 = ' UPDATE vc_user SET user_this_month_market_value = 0,team_this_month_market_value =0,user_this_month_turnover_value=0 ';
DB::update(DB::raw($update_sql2));

$CNYPrice  交易流水全部转化成了人民币..

//把user_account里面的资产 存储到临时表里面.
$insert_time = time();
$sql = 'INSERT INTO vc_' . $table_name . '(user_id,vcoin_type,money_holding,account_type,market_value,insert_time,Y,YM,YMD) select user_id,vcoin_code,balance,account_type,balance*' . $CNYPrice . ',"' . $insert_time . '","' . $Y . '","' . $YM . '","' . $yestoday . '" from vc_user_account where vcoin_code="' . $v['code'] . '" ';
DB::insert(DB::raw($sql));

//固化个人本月流水市值  查询user_account表和 user_account_log表的数据填充到 user流水表里面
$update_sql = ' UPDATE vc_user u SET user_this_month_turnover_value = user_this_month_turnover_value+(select sum(if(ual.direct="out",-ual.count*' . $CNYPrice . ',ual.count*' . $CNYPrice . ')) from vc_user_account ua left join vc_user_account_log ual on ual.user_account_id=ua.id where ua.vcoin_code="' . $v['code'] . '" and ual.user_id=u.id and ual.created_at BETWEEN "'.$YESTODAY_YMD.' 00:00:01" AND "'.$YESTODAY_YMD.' 23:59:59") ';
DB::update(DB::raw($update_sql));

//固化本月个人市值
$update_sql = ' UPDATE vc_user u SET user_this_month_market_value = (select sum(market_value)/' . $day . ' from vc_' . $table_name . ' where YM="' . $YM . '" and user_id=u.id) ';
DB::update(DB::raw($update_sql));

//固化本月团队市值
$team_update_sql = ' UPDATE vc_user u SET team_this_month_market_value = (select sum(market_value)/' . $day . ' from vc_' . $table_name . ' where YM="' . $YM . '" and (user_id=u.id or user_id in (SELECT id FROM (SELECT id,pid,pid2,pid3 FROM vc_user where pid>0 ) as b where b.pid = u.id OR b.pid2 = u.id OR b.pid3 = u.id)) )';
DB::update(DB::raw($team_update_sql));


INSERT INTO vc_user_snapshot_201904(user_id,vcoin_type,money_holding,account_type,market_value,insert_time,Y,YM,YMD) select user_id,vcoin_code,balance,account_type,balance*10,"1554711296","2019","201904","20190407" from vc_user_account where vcoin_code="GTC"   

UPDATE vc_user u SET user_this_month_turnover_value = user_this_month_turnover_value+(select sum(if(ual.direct="out",-ual.count*10,ual.count*10)) from vc_user_account ua left join vc_user_account_log ual on ual.user_account_id=ua.id where ua.vcoin_code="GTC" and ual.user_id=u.id and ual.created_at BETWEEN "2019-04-07 00:00:01" AND "2019-04-07 23:59:59")   


INSERT INTO vc_user_snapshot_201904(user_id,vcoin_type,money_holding,account_type,market_value,insert_time,Y,YM,YMD) select user_id,vcoin_code,balance,account_type,balance*1,"1554711296","2019","201904","20190407" from vc_user_account where vcoin_code="JBT"   

UPDATE vc_user u SET user_this_month_turnover_value = user_this_month_turnover_value+(select sum(if(ual.direct="out",-ual.count*1,ual.count*1)) from vc_user_account ua left join vc_user_account_log ual on ual.user_account_id=ua.id where ua.vcoin_code="JBT" and ual.user_id=u.id and ual.created_at BETWEEN "2019-04-07 00:00:01" AND "2019-04-07 23:59:59")

INSERT INTO vc_user_snapshot_201904(user_id,vcoin_type,money_holding,account_type,market_value,insert_time,Y,YM,YMD) select user_id,vcoin_code,balance,account_type,balance*0.8,"1554711296","2019","201904","20190407" from vc_user_account where vcoin_code="ZGC"

UPDATE vc_user u SET user_this_month_turnover_value = user_this_month_turnover_value+(select sum(if(ual.direct="out",-ual.count*0.8,ual.count*0.8)) from vc_user_account ua left join vc_user_account_log ual on ual.user_account_id=ua.id where ua.vcoin_code="ZGC" and ual.user_id=u.id and ual.created_at BETWEEN "2019-04-07 00:00:01" AND "2019-04-07 23:59:59")   

UPDATE vc_user u SET user_this_month_market_value = (select sum(market_value)/1 from vc_user_snapshot_201904 where YM="201904" and user_id=u.id)   

UPDATE vc_user u SET team_this_month_market_value = (select sum(market_value)/1 from vc_user_snapshot_201904 where YM="201904" and (user_id=u.id or user_id in (SELECT id FROM (SELECT id,pid,pid2,pid3 FROM vc_user where pid>0 ) as b where b.pid = u.id OR b.pid2 = u.id OR b.pid3 = u.id)) )

```

#### 系统相关

```

普通推荐奖：
	当用户产生交易，他的上一级获取交易手续费的30%;
合伙人推荐奖:
	1.推荐奖:  当下级用户产生交易手续费, 上一级合伙人手续费用的20% ,上上级如果是合伙人则奖励10%的手续费
	2.培育奖:  当下级用户也是合伙人,  则当用户发生交易时, 上上级合伙人收取当前合伙人的20%团队奖励
	3.团队级差奖: 即下级在等级没有超越自己的情况下 获取团队交易手续费的 级差奖励.
合伙人分红:
	每次合伙人发放奖励时  记录分红值,分红值用来计算 平台发放利润 给合伙人 比率依据
   

```





##### 服务器相关

```命令行

GIT
http://192.168.0.186:81/jiaoyisuo/site/tree/Dev

接口文档
http://192.168.0.186:4999/web/#/1?page_id=5
账号: konglingping@126.com
      konglongping@126.com
密码:
	admin8899

Linux 服务器:
47.74.152.68
root
SM!CNykSN6uIn@9xMi5

nN9J7ZOV3$oWClWH!%N

2019huhy..
上传监控地址: http://192.168.0.186:8090

数据库:
47.74.128.243
root
zVBmsp1YKVhSoua1n4
2019guhy..


本地Linux centos7:
root
admin8899


47.75.213.11 
root 
2019csh..

vpn
2019csh



ShadowsocksR账号 配置信息【OK】：

I P : 47.75.213.11
端口 : 2333
密码 : doub.io
加密 : aes-256-cfb
协议 : auth_sha1_v4
混淆 : plain

```



#### TYPORA

```
配置文件night.css
#write{
    max-width:914px;
}
@media(min-width:1500px){
    #write{
        min-width:1300px;
    }
}

```

```
`id`,  `code`,  `name` ,  `sort`,  `basic`,  `rechargeable`,  `withdrawable`,  `tradable` ,  `futuretradable`,  `face_value`,  `withdraw_min_count`,  `withdraw_max_count`,  `withdraw_vip_max_count`,  `withdraw_service_fee`,  `goods_sell_service_rate`,  `goods_buy_service_rate`,  `goods_user_service_rate`,  `status`,  `basic_type`,  `coin_type`,  `token_id`,  `decimals`,  `token_decimals`,  `value_equals_coin`,  `platform_agent_id`,  `leverage_ratios`,  `created_at`,  `updated_at`

```

### Laravel源码分析

```
入口 index.php
引入 app.php ==> 加载Composer生成的自动加载文件 vendor/autoload.php文件 并实例化 Application 实例化$app  或 app();

然后注册服务 provider 或 中间件 middleware
    $app->register();
    $app->routeMiddleware();
    $app->singleton();
    class_alias("app\Facede\User","User");//创建类别名..

最后执行run()方法:
     $response = $this->dispatch($request);  分发请求到指定路由到Controller
     //执行响应. 输出响应内容
     if ($response instanceof SymfonyResponse) {
        $response->send();
     } else {
        echo (string) $response;
    }
```

#### Laravel容器 服务

```
Application Containner  服务容器:
提供的注册服务的方法有:
1.简单绑定
    $app->bind('要绑定的类名或接口名',function(){
        return $instance; 返回绑定类或接口的实例
    });
2.绑定一个单例
	$app->singletone('要绑定的类名或接口名',function($app){
		return $instance; 返回绑定类或接口的实例  一旦单例绑定被解析，相同的对象实例会在随后的调用中返回到容器中：
	});
3.直接绑定实例
	$app->instance('要绑定的类名或接口名',new UserInstance());
4.绑定要接口实现
	$app->bind(
		'interface/UserInterface',
		'service/UserService'
	);
5.上下文绑定
	$app->when(PhotoController::class)
          ->needs(Filesystem::class)
          ->give(function () {
              return Storage::disk('local');
           });
6.扩展绑定  方法可以修改已解析的服务.
	比如，当一个服务被解析后，你可以添加额外的代码来修饰或者配置它,方法接受一个闭包，该闭包唯一的参数就是这个服务， 并返回修改过的服务：
	$app->extend(UserService::Class,function($service){
		return new DecoratedService($service);
	});

解析实例：
make() 方法解析实例
	$app->make('user'); make方法接收你想要解析的类或接口的名字;
	如果你的代码处于无法访问 $app 变量的位置，则可用全局辅助函数 resolve 来解析
	$userInstance=resolve('user');
	如果类依赖不能通过容器解析，你可以通过将它们作为关联数组作为 makeWith 方法的参数注入
	$api = $this->app->makeWith('HelpSpot\API', ['id' => 1]);
注入实例
use app\UserService;
class UserController extends Controller{
	protected $user;
	public function __contruct(UserService $user){
		$this->user=$user;
	}
}
服务容器每次解析对象会触发一个事件，你可以使用 resolving 方法监听这个事件 :
$app->resolving(HelpSpot\API::class, function ($api, $app) {
    // Called when container resolves objects of type "HelpSpot\API"...
});

```

#### 服务器提供者 provider

```
所有的服务提供者都会继承 Illuminate\Support\ServiceProvider 类。 大多服务提供者都包含一个 register 和一个 boot 方法。在 register 方法中， 你只需要将事物绑定到服务容器。而不要尝试在 register 方法中注册任何监听器，路由，或者其他任何功能 如果我们要在服务提供者中注册一个 视图合成器 该怎么做？ 这就需要用到 boot 方法了。 该方法在所有服务提供者被注册以后才会被调用， 这就是说我们可以在其中访问框架已注册的所有其它服务：
namespace App\Providers;
class AppProvider extends ServiceProvider{

	public function register(){
		$this->app->singleton(UserInterfade::class,function($app){
			return new UserService(config('username'));
		});
	}
	/*
	*如果你的服务提供器注册了许多简单的绑定，你可能想用 bindings 和 singletons 属性替代手动注册每个容器绑定。
	*当服务提供器被框架加载时，将自动检查这些属性并注册相应的绑定
	*/
	public $bindings=[
		UserInterface::class=>UserService::class,
		Auth::class=>AuthManager::class
	];
	public $singletons=[
		UserInterface::class=>UserService::class,
		Auth::class=>AuthManager::class
	];
	/**
	*如果我们要在服务提供者中注册一个 视图合成器 该怎么做？ 这就需要用到 boot 方法了。 
	* " 该方法在所有服务提供者被注册以后才会被调用 "， 这就是说我们可以在其中访问框架已注册的所有其它服务
	*/
	public function boot(){
			view()->composer('view',function(){
				//
			});
	}
	// use Illuminate\Contracts\Routing\ResponseFactory;
    public function boot(ResponseFactory $response)
    {
        $response->macro('caps', function ($value) {});
    }
}
注册服务提供者:在配置文件添加:
    config/app.php
    'provider'=>[
        App\Providers\AppProvider::class,
    ]
```

#### Facades 门面

```
Facades 为应用的 服务容器 提供了一个「静态」 接口。Laravel 自带了很多 Facades，可以访问绝大部分功能。Laravel Facades 实际是服务容器中底层类的 「静态代理」 ，相对于传统静态方法，在使用时能够提供更加灵活、更加易于测试、更加优雅的语法。
所有的 Laravel Facades 都定义在 Illuminate\Support\Facades 命名空间下。所以，我们可以轻松的使用 Facade
Facade 和辅助函数之间没有实际的区别。当你使用辅助函数时，你可以像测试相应的 Facade 那样进行测试 [主要实现了快捷访问方式]
	app\Facades\TestFacade.php::::::::::::
    namespace App\Facades;
    class TestFacade extends Facade{
        protected static function getFacadeAccessor(){
            return 'test';
        }
    }
调用 Helper::info();  首先实例化 服务容器中绑定 helper 实例 然后通过魔术方法 __callStatic() 方法调用实例化出来对象的对应的动态方法
相当于  $a=new Helper(); $a->info();

app\Test.php  服务类
    class Test{
        public function info(){
            return 'test';
        }
    }
app.php
	注册实例到服务容器
	$app->singleton('test',App\Test::class);
```

#### 合约 contracts

```
contracts 用以实现面向接口编程;
定义Contracts

interface CacheRepository{
	public function get();
	public function set();
	public function update();
}

class Redis implements CacheRepository{
	public function get(){}
	public function set(){}
	public function update(){}
}
注入容器:
	$app->singletone(CacheReposiory::class,Redis::class);
使用:
class DaController extends Controller{
	public $cache;
	public function __construct(CacheRepository $cache){
		$this->cache=$cache;
	}
}
```

#### 中间件 Middleware

```
中间件为过滤进入应用的 Http请求提供的便利的机制..比如登录验证，权限验证.csrf保护等;
自动生成中间件:
	php artisan make:middleware  ProtectMiddleware
定义中间件:
    class ProtectMiddleware{
        public function __contruct(){

        }
        public function handle($request,Closure $next,$guard){
            //继续之前执行的代码
            $response=$next($request);
            //执行之后执行的代码
            return $response;
        }
    }
注册中间件:
	若是希望中间件在应用处理每个 HTTP 请求期间运行
	$app->middleware([
		ProtectMiddleware::class
	]);
	为路由分配中间件
	$app->routeMiddleware([
		'protectr'=>ProtectMiddleware::class
	]);
使用中间件:
	为路由分配中间
	$router->get('/',['middleware'=>'protectr',function(){
	
	}]);
	$router->group(['middleware'=>'protectr'],function($app){
		$app->any('/user/get/{id}','UserController@index');
		$app->get('/user/edit/{id}','UserController@edit');
	});

```



### 消息队列(message queue)

####Kafka

```



```

#### ActiveMq

```



```

#### RabbitMQ

```



```





